// Code generated by MockGen. DO NOT EDIT.
// Source: internal/port/cache.go
//
// Generated by this command:
//
//	mockgen -source=internal/port/cache.go -destination=test/mocks/mock_cache.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	time "time"

	gomock "go.uber.org/mock/gomock"
)

// MockCache is a mock of Cache interface.
type MockCache struct {
	ctrl     *gomock.Controller
	recorder *MockCacheMockRecorder
	isgomock struct{}
}

// MockCacheMockRecorder is the mock recorder for MockCache.
type MockCacheMockRecorder struct {
	mock *MockCache
}

// NewMockCache creates a new mock instance.
func NewMockCache(ctrl *gomock.Controller) *MockCache {
	mock := &MockCache{ctrl: ctrl}
	mock.recorder = &MockCacheMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCache) EXPECT() *MockCacheMockRecorder {
	return m.recorder
}

// Delete mocks base method.
func (m *MockCache) Delete(ctx context.Context, key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockCacheMockRecorder) Delete(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockCache)(nil).Delete), ctx, key)
}

// DeleteByPattern mocks base method.
func (m *MockCache) DeleteByPattern(ctx context.Context, pattern string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteByPattern", ctx, pattern)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteByPattern indicates an expected call of DeleteByPattern.
func (mr *MockCacheMockRecorder) DeleteByPattern(ctx, pattern any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteByPattern", reflect.TypeOf((*MockCache)(nil).DeleteByPattern), ctx, pattern)
}

// Exists mocks base method.
func (m *MockCache) Exists(ctx context.Context, key string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exists", ctx, key)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exists indicates an expected call of Exists.
func (mr *MockCacheMockRecorder) Exists(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockCache)(nil).Exists), ctx, key)
}

// Get mocks base method.
func (m *MockCache) Get(ctx context.Context, key string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, key)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockCacheMockRecorder) Get(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCache)(nil).Get), ctx, key)
}

// Set mocks base method.
func (m *MockCache) Set(ctx context.Context, key, value string, expiration time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Set", ctx, key, value, expiration)
	ret0, _ := ret[0].(error)
	return ret0
}

// Set indicates an expected call of Set.
func (mr *MockCacheMockRecorder) Set(ctx, key, value, expiration any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockCache)(nil).Set), ctx, key, value, expiration)
}

// MockAuthorizationCache is a mock of AuthorizationCache interface.
type MockAuthorizationCache struct {
	ctrl     *gomock.Controller
	recorder *MockAuthorizationCacheMockRecorder
	isgomock struct{}
}

// MockAuthorizationCacheMockRecorder is the mock recorder for MockAuthorizationCache.
type MockAuthorizationCacheMockRecorder struct {
	mock *MockAuthorizationCache
}

// NewMockAuthorizationCache creates a new mock instance.
func NewMockAuthorizationCache(ctrl *gomock.Controller) *MockAuthorizationCache {
	mock := &MockAuthorizationCache{ctrl: ctrl}
	mock.recorder = &MockAuthorizationCacheMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthorizationCache) EXPECT() *MockAuthorizationCacheMockRecorder {
	return m.recorder
}

// GetDecision mocks base method.
func (m *MockAuthorizationCache) GetDecision(ctx context.Context, userID int64, resource, action string) (bool, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetDecision", ctx, userID, resource, action)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetDecision indicates an expected call of GetDecision.
func (mr *MockAuthorizationCacheMockRecorder) GetDecision(ctx, userID, resource, action any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDecision", reflect.TypeOf((*MockAuthorizationCache)(nil).GetDecision), ctx, userID, resource, action)
}

// InvalidateAll mocks base method.
func (m *MockAuthorizationCache) InvalidateAll(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InvalidateAll", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// InvalidateAll indicates an expected call of InvalidateAll.
func (mr *MockAuthorizationCacheMockRecorder) InvalidateAll(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InvalidateAll", reflect.TypeOf((*MockAuthorizationCache)(nil).InvalidateAll), ctx)
}

// InvalidateUser mocks base method.
func (m *MockAuthorizationCache) InvalidateUser(ctx context.Context, userID int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InvalidateUser", ctx, userID)
	ret0, _ := ret[0].(error)
	return ret0
}

// InvalidateUser indicates an expected call of InvalidateUser.
func (mr *MockAuthorizationCacheMockRecorder) InvalidateUser(ctx, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InvalidateUser", reflect.TypeOf((*MockAuthorizationCache)(nil).InvalidateUser), ctx, userID)
}

// SetDecision mocks base method.
func (m *MockAuthorizationCache) SetDecision(ctx context.Context, userID int64, resource, action string, allowed bool, expiration time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetDecision", ctx, userID, resource, action, allowed, expiration)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetDecision indicates an expected call of SetDecision.
func (mr *MockAuthorizationCacheMockRecorder) SetDecision(ctx, userID, resource, action, allowed, expiration any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetDecision", reflect.TypeOf((*MockAuthorizationCache)(nil).SetDecision), ctx, userID, resource, action, allowed, expiration)
}

// MockTokenCache is a mock of TokenCache interface.
type MockTokenCache struct {
	ctrl     *gomock.Controller
	recorder *MockTokenCacheMockRecorder
	isgomock struct{}
}

// MockTokenCacheMockRecorder is the mock recorder for MockTokenCache.
type MockTokenCacheMockRecorder struct {
	mock *MockTokenCache
}

// NewMockTokenCache creates a new mock instance.
func NewMockTokenCache(ctrl *gomock.Controller) *MockTokenCache {
	mock := &MockTokenCache{ctrl: ctrl}
	mock.recorder = &MockTokenCacheMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenCache) EXPECT() *MockTokenCacheMockRecorder {
	return m.recorder
}

// BlacklistToken mocks base method.
func (m *MockTokenCache) BlacklistToken(ctx context.Context, tokenID string, expiration time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BlacklistToken", ctx, tokenID, expiration)
	ret0, _ := ret[0].(error)
	return ret0
}

// BlacklistToken indicates an expected call of BlacklistToken.
func (mr *MockTokenCacheMockRecorder) BlacklistToken(ctx, tokenID, expiration any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BlacklistToken", reflect.TypeOf((*MockTokenCache)(nil).BlacklistToken), ctx, tokenID, expiration)
}

// IsBlacklisted mocks base method.
func (m *MockTokenCache) IsBlacklisted(ctx context.Context, tokenID string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsBlacklisted", ctx, tokenID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsBlacklisted indicates an expected call of IsBlacklisted.
func (mr *MockTokenCacheMockRecorder) IsBlacklisted(ctx, tokenID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsBlacklisted", reflect.TypeOf((*MockTokenCache)(nil).IsBlacklisted), ctx, tokenID)
}

// MockRateLimitCache is a mock of RateLimitCache interface.
type MockRateLimitCache struct {
	ctrl     *gomock.Controller
	recorder *MockRateLimitCacheMockRecorder
	isgomock struct{}
}

// MockRateLimitCacheMockRecorder is the mock recorder for MockRateLimitCache.
type MockRateLimitCacheMockRecorder struct {
	mock *MockRateLimitCache
}

// NewMockRateLimitCache creates a new mock instance.
func NewMockRateLimitCache(ctrl *gomock.Controller) *MockRateLimitCache {
	mock := &MockRateLimitCache{ctrl: ctrl}
	mock.recorder = &MockRateLimitCacheMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRateLimitCache) EXPECT() *MockRateLimitCacheMockRecorder {
	return m.recorder
}

// GetCount mocks base method.
func (m *MockRateLimitCache) GetCount(ctx context.Context, key string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCount", ctx, key)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCount indicates an expected call of GetCount.
func (mr *MockRateLimitCacheMockRecorder) GetCount(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCount", reflect.TypeOf((*MockRateLimitCache)(nil).GetCount), ctx, key)
}

// Increment mocks base method.
func (m *MockRateLimitCache) Increment(ctx context.Context, key string, expiration time.Duration) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Increment", ctx, key, expiration)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Increment indicates an expected call of Increment.
func (mr *MockRateLimitCacheMockRecorder) Increment(ctx, key, expiration any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Increment", reflect.TypeOf((*MockRateLimitCache)(nil).Increment), ctx, key, expiration)
}

// Reset mocks base method.
func (m *MockRateLimitCache) Reset(ctx context.Context, key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Reset", ctx, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// Reset indicates an expected call of Reset.
func (mr *MockRateLimitCacheMockRecorder) Reset(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reset", reflect.TypeOf((*MockRateLimitCache)(nil).Reset), ctx, key)
}

// MockRefreshTokenCache is a mock of RefreshTokenCache interface.
type MockRefreshTokenCache struct {
	ctrl     *gomock.Controller
	recorder *MockRefreshTokenCacheMockRecorder
	isgomock struct{}
}

// MockRefreshTokenCacheMockRecorder is the mock recorder for MockRefreshTokenCache.
type MockRefreshTokenCacheMockRecorder struct {
	mock *MockRefreshTokenCache
}

// NewMockRefreshTokenCache creates a new mock instance.
func NewMockRefreshTokenCache(ctrl *gomock.Controller) *MockRefreshTokenCache {
	mock := &MockRefreshTokenCache{ctrl: ctrl}
	mock.recorder = &MockRefreshTokenCacheMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRefreshTokenCache) EXPECT() *MockRefreshTokenCacheMockRecorder {
	return m.recorder
}

// StoreRefreshToken mocks base method.
func (m *MockRefreshTokenCache) StoreRefreshToken(ctx context.Context, tokenID string, userID int64, expiration time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreRefreshToken", ctx, tokenID, userID, expiration)
	ret0, _ := ret[0].(error)
	return ret0
}

// StoreRefreshToken indicates an expected call of StoreRefreshToken.
func (mr *MockRefreshTokenCacheMockRecorder) StoreRefreshToken(ctx, tokenID, userID, expiration any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreRefreshToken", reflect.TypeOf((*MockRefreshTokenCache)(nil).StoreRefreshToken), ctx, tokenID, userID, expiration)
}

// GetRefreshToken mocks base method.
func (m *MockRefreshTokenCache) GetRefreshToken(ctx context.Context, tokenID string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRefreshToken", ctx, tokenID)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRefreshToken indicates an expected call of GetRefreshToken.
func (mr *MockRefreshTokenCacheMockRecorder) GetRefreshToken(ctx, tokenID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRefreshToken", reflect.TypeOf((*MockRefreshTokenCache)(nil).GetRefreshToken), ctx, tokenID)
}

// DeleteRefreshToken mocks base method.
func (m *MockRefreshTokenCache) DeleteRefreshToken(ctx context.Context, tokenID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteRefreshToken", ctx, tokenID)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteRefreshToken indicates an expected call of DeleteRefreshToken.
func (mr *MockRefreshTokenCacheMockRecorder) DeleteRefreshToken(ctx, tokenID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteRefreshToken", reflect.TypeOf((*MockRefreshTokenCache)(nil).DeleteRefreshToken), ctx, tokenID)
}

// DeleteUserRefreshTokens mocks base method.
func (m *MockRefreshTokenCache) DeleteUserRefreshTokens(ctx context.Context, userID int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteUserRefreshTokens", ctx, userID)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteUserRefreshTokens indicates an expected call of DeleteUserRefreshTokens.
func (mr *MockRefreshTokenCacheMockRecorder) DeleteUserRefreshTokens(ctx, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUserRefreshTokens", reflect.TypeOf((*MockRefreshTokenCache)(nil).DeleteUserRefreshTokens), ctx, userID)
}

// GetUserTokens mocks base method.
func (m *MockRefreshTokenCache) GetUserTokens(ctx context.Context, userID int64) (map[string]int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUserTokens", ctx, userID)
	ret0, _ := ret[0].(map[string]int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUserTokens indicates an expected call of GetUserTokens.
func (mr *MockRefreshTokenCacheMockRecorder) GetUserTokens(ctx, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserTokens", reflect.TypeOf((*MockRefreshTokenCache)(nil).GetUserTokens), ctx, userID)
}
